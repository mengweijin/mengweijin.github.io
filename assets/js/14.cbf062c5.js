(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{388:function(a,s,t){a.exports=t.p+"assets/img/HashMap.f934bb35.png"},389:function(a,s,t){a.exports=t.p+"assets/img/put.5ac31598.jpg"},491:function(a,s,t){"use strict";t.r(s);var e=t(28),n=Object(e.a)({},(function(){var a=this,s=a.$createElement,e=a._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h2",{attrs:{id:"java-util-map-的实现类-hashmap、hashtable、linkedhashmap、treemap、concurrenthashmap-之间的关系"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#java-util-map-的实现类-hashmap、hashtable、linkedhashmap、treemap、concurrenthashmap-之间的关系"}},[a._v("#")]),a._v(" java.util.Map 的实现类 HashMap、Hashtable、LinkedHashMap、TreeMap、ConcurrentHashMap 之间的关系")]),a._v(" "),e("h3",{attrs:{id:"hashmap-与-hashtable-的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#hashmap-与-hashtable-的区别"}},[a._v("#")]),a._v(" HashMap 与 HashTable 的区别？")]),a._v(" "),e("ul",[e("li",[a._v("HashMap 线程不安全，Hashtable 线程安全")]),a._v(" "),e("li",[a._v("HashMap 允许 K/V 都为 null；后者 K/V 都不允许为 null")]),a._v(" "),e("li",[a._v("HashMap 继承自 AbstractMap 类；而 Hashtable 继承自 Dictionary 类")])]),a._v(" "),e("h3",{attrs:{id:"concurrenthashmap-和-hashtable-的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#concurrenthashmap-和-hashtable-的区别"}},[a._v("#")]),a._v(" ConcurrentHashMap 和 HashTable 的区别？")]),a._v(" "),e("p",[a._v("ConcurrentHashMap 结合了 HashMap 和 HashTable 二者的优势。HashMap 没有考虑同步，HashTable 考虑了同步的问题。")]),a._v(" "),e("p",[a._v("但是 HashTable 在每次同步执行时都要锁住整个结构，ConcurrentHashMap 锁的方式是稍微细粒度的")]),a._v(" "),e("h3",{attrs:{id:"同步集合-hashtable-与并发集合-concurrenthashmap"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#同步集合-hashtable-与并发集合-concurrenthashmap"}},[a._v("#")]),a._v(" 同步集合 HashTable 与并发集合 ConcurrentHashMap ？")]),a._v(" "),e("p",[a._v("Collections.synchronizedMap() 方法可以获取一个线程安全的 map，称为同步集合，锁住整个方法（粗粒度）")]),a._v(" "),e("p",[a._v("ConcurrentHashMap 是并发集合，锁是细粒度的，性能更高")]),a._v(" "),e("p",[a._v("ConcurrentHashMap，它内部细分了若干个小的HashMap，称之为段(Segment)。默认情况下一个 ConcurrentHashMap 被进一步细分为 16 个段，既就是锁的并发度（分段锁）")]),a._v(" "),e("p",[a._v("不管是同步集合还是并发集合，都能保证线程安全，但建议使用并发集合")]),a._v(" "),e("h3",{attrs:{id:"linkedhashmap-和-treemap"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#linkedhashmap-和-treemap"}},[a._v("#")]),a._v(" LinkedHashMap 和 Treemap")]),a._v(" "),e("p",[a._v("LinkedHashMap 按插入顺序存储，TreeMap 可对键排序")]),a._v(" "),e("h2",{attrs:{id:"存储结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#存储结构"}},[a._v("#")]),a._v(" 存储结构")]),a._v(" "),e("p",[a._v("java 7 采用数组 + 单向链表，java 8 采用数组 + 单向链表 + 红黑树")]),a._v(" "),e("p",[e("img",{attrs:{src:t(388),alt:"image"}})]),a._v(" "),e("p",[a._v("HashMap就是使用哈希表来存储的。哈希表为解决冲突，可以采用开放地址法和链地址法等来解决问题，Java中HashMap采用了链地址法。链地址法，简单来说，就是数组加链表的结合。在每个数组元素上都有一个链表结构，当数据被Hash后，得到数组下标，把数据放在对应下标元素的链表上 。")]),a._v(" "),e("p",[a._v("Hash算法计算结果越分散均匀，Hash碰撞的概率就越小，map的存取效率就会越高")]),a._v(" "),e("p",[a._v("如果哈希桶数组很大，即使较差的Hash算法也会比较分散，如果哈希桶数组数组很小，即使好的Hash算法也会出现较多碰撞，所以就需要在空间成本和时间成本之间权衡，其实就是在根据实际情况确定哈希桶数组的大小，并在此基础上设计好的hash算法减少Hash碰撞")]),a._v(" "),e("p",[a._v("几个字段：")]),a._v(" "),e("div",{staticClass:"language-java line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-java"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("final")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" DEFAULT_INITIAL_CAPACITY "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<<")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("4")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//默认初始化大小 16 ")]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" threshold"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 所能容纳的key-value对极限，threshold = length * loadFactor，length默认16，当超过threshold就要扩容，length就是Entry数组的长度，一定是2的n次方，即每次扩容一倍")]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("final")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("float")]),a._v(" loadFactor"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 负载因子，默认0.75")]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" modCount"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//记录HashMap内部结构发生变化的次数")]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" size"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//实际存储的kv对个数")]),a._v("\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br")])]),e("p",[a._v("即使负载因子和Hash算法设计的再合理，也免不了会出现拉链过长的情况，一旦出现链表过长，则会严重影响 HashMap 的性能。于是，在JDK1.8版本中，对数据结构做了进一步的优化，引入了红黑树。而当链表长度太长（默认超过8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高 HashMap 的性能")]),a._v(" "),e("h2",{attrs:{id:"根据-key-获取哈希桶数组索引位置"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#根据-key-获取哈希桶数组索引位置"}},[a._v("#")]),a._v(" 根据 key 获取哈希桶数组索引位置")]),a._v(" "),e("p",[a._v("不管增加、删除、查找键值对，定位到哈希桶数组的位置都是很关键的第一步")]),a._v(" "),e("p",[a._v("这里的Hash算法本质上就是三步：取key的hashCode值、高位运算、取模运算")]),a._v(" "),e("div",{staticClass:"language-java line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-java"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//源码的实现(方法一+方法二):")]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//方法一：jdk1.8 & jdk1.7")]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("final")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[a._v("hash")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),e("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),a._v(" key"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v(" \n   \n    "),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//key.hashCode()    第一步.取hashCode值")]),a._v("\n    "),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//h >>> 16          第二步.高位参与运算")]),a._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" h"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("key "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("==")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("null")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("?")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("h "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" key"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[a._v("hashCode")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("^")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("h "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">>>")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("16")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n \n"),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//方法二：jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的")]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[a._v("indexFor")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" h"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" length"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v(" \n    "),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//第三步.取模运算，相当于h%length,但效率更高")]),a._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" h "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("&")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("length"),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br"),e("span",{staticClass:"line-number"},[a._v("6")]),e("br"),e("span",{staticClass:"line-number"},[a._v("7")]),e("br"),e("span",{staticClass:"line-number"},[a._v("8")]),e("br"),e("span",{staticClass:"line-number"},[a._v("9")]),e("br"),e("span",{staticClass:"line-number"},[a._v("10")]),e("br"),e("span",{staticClass:"line-number"},[a._v("11")]),e("br"),e("span",{staticClass:"line-number"},[a._v("12")]),e("br"),e("span",{staticClass:"line-number"},[a._v("13")]),e("br"),e("span",{staticClass:"line-number"},[a._v("14")]),e("br"),e("span",{staticClass:"line-number"},[a._v("15")]),e("br")])]),e("h2",{attrs:{id:"put方法原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#put方法原理"}},[a._v("#")]),a._v(" put方法原理")]),a._v(" "),e("p",[e("img",{attrs:{src:t(389),alt:"image"}})]),a._v(" "),e("p",[a._v("注：table就是数组，table[i]就是数组的第i个元素")]),a._v(" "),e("ol",[e("li",[a._v("判断键值对数组table是否为空或为null，否则执行resize()进行扩容；")]),a._v(" "),e("li",[a._v("根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向6，如果table[i]不为空，转向3")]),a._v(" "),e("li",[a._v("判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向4，这里的相同指的是hashCode以及equals")]),a._v(" "),e("li",[a._v("判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向5")]),a._v(" "),e("li",[a._v("遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可")]),a._v(" "),e("li",[a._v("插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容")])]),a._v(" "),e("h2",{attrs:{id:"扩容机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#扩容机制"}},[a._v("#")]),a._v(" 扩容机制")]),a._v(" "),e("p",[a._v("数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组")]),a._v(" "),e("p",[a._v("扩容是一个特别耗性能的操作，所以当程序员在使用HashMap的时候，估算map的大小，初始化的时候给一个大致的数值，避免map进行频繁的扩容")]),a._v(" "),e("h2",{attrs:{id:"为什么链表长度超过8就转化为红黑树"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#为什么链表长度超过8就转化为红黑树"}},[a._v("#")]),a._v(" 为什么链表长度超过8就转化为红黑树？")]),a._v(" "),e("p",[a._v("HashMap在jdkL8之后弓|入了红黑树的概念，表示若桶中链表元素超过 8 时，会自动转化成红黑树；若桶中元素小于等于 6 时，树结构还原成链表形式。")]),a._v(" "),e("p",[a._v("原因：")]),a._v(" "),e("p",[a._v("红黑树的平均查找长度是log(n), 长度为 8, 查找长度为log(8)=3, 链表的平均查找长度为n/2, 当长度为8时，平均查找长度为8/2=4, 这才有转换成树的 必要；链表长度如果是小于等于6, 6/2=3, 虽然速度也很快的，但是转化为树结构和生成树的时间并不会太短。")]),a._v(" "),e("p",[a._v("还有选择 6 和 8 的原因是：")]),a._v(" "),e("p",[a._v("中间有个差值7可以防止链表和树之间婕的转换。假设一下，如果设计成链表个数超过 8 则链表转换成树结构，链表个数小于 8 则树结构转换成链表，如果一个 HashMap 不停的插入、删除元素，链表个数在8左右勾胭，就会顷繁的发生树转链表、链表转树，效率会很低。")]),a._v(" "),e("h2",{attrs:{id:"hashmap的key为自定义对象时-要重写equals和hashcode方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#hashmap的key为自定义对象时-要重写equals和hashcode方法"}},[a._v("#")]),a._v(" hashmap的key为自定义对象时，要重写equals和hashcode方法")]),a._v(" "),e("p",[a._v("因为hashmap是根据哈希值计算的，当自定义对象的属性完全相同，但hashcode可能不同，因此要重写hashcode方法。重写hashcode则equals必须重写")])])}),[],!1,null,null,null);s.default=n.exports}}]);