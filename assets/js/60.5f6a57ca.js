(window.webpackJsonp=window.webpackJsonp||[]).push([[60],{476:function(t,r,a){"use strict";a.r(r);var e=a(28),i=Object(e.a)({},(function(){var t=this,r=t.$createElement,a=t._self._c||r;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"什么是写时复制容器-copyonwritearraylist-和-copyonwritearrayset"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是写时复制容器-copyonwritearraylist-和-copyonwritearrayset"}},[t._v("#")]),t._v(" 什么是写时复制容器 CopyOnWriteArrayList 和 CopyOnWriteArraySet")]),t._v(" "),a("p",[t._v("CopyOnWrite 容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行 Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。")]),t._v(" "),a("p",[t._v("这样做的好处是我们可以对 CopyOnWrite 容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以 CopyOnWrite 容器也是一种读写分离的思想，读和写不同的容器。如果读的时候有多个线程正在向 CopyOnWriteArrayList 添加数据，读还是会读到旧的数据，因为写的时候不会锁住旧的 CopyOnWriteArrayList。")]),t._v(" "),a("p",[t._v("CopyOnWrite 并发容器用于对于绝大部分访问都是读，且只是偶尔写的并发场景。比如白名单，黑名单，商品类目的访问和更新场景，假如我们有一个搜索网站，用户在这个网站的搜索框中，输入关键字搜索内容，但是某些关键字不允许被搜索。这些不能被搜索的关键字会被放在一个黑名单当中，黑名单每天晚上更新一次。当用户搜索时，会检查当前关键字在不在黑名单当中，如果在，则提示不能搜索。")]),t._v(" "),a("p",[t._v("使用 CopyOnWriteMap 需要注意两件事情：")]),t._v(" "),a("ol",[a("li",[t._v("减少扩容开销。根据实际需要，初始化 CopyOnWriteMap 的大小，避免写时 CopyOnWriteMap 扩容的开销。")]),t._v(" "),a("li",[t._v("使用批量添加。因为每次添加，容器每次都会进行复制，所以减少添加次数，可以减少容器的复制次数。")])]),t._v(" "),a("h2",{attrs:{id:"写时复制容器的问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#写时复制容器的问题"}},[t._v("#")]),t._v(" 写时复制容器的问题")]),t._v(" "),a("h3",{attrs:{id:"性能问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#性能问题"}},[t._v("#")]),t._v(" 性能问题")]),t._v(" "),a("p",[t._v("每次修改都创建一个新数组，然后复制所有内容，如果数组比较大，修改操作又比较频繁，可以想象，性能是很低的，而且内存开销会很大。")]),t._v(" "),a("h3",{attrs:{id:"数据一致性问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据一致性问题"}},[t._v("#")]),t._v(" 数据一致性问题")]),t._v(" "),a("p",[t._v("CopyOnWrite 容器只能保证数据的最终一致性，不能保证数据的实时一致性。 所以如果你希望写入的的数据，马上能读到，不要使用 CopyOnWrite 容器。")])])}),[],!1,null,null,null);r.default=i.exports}}]);